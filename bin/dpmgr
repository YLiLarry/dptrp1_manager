#!/usr/bin/env python
# coding=utf-8

import argparse
import sys
import os

import dptrp1manager

class DPTRP1(object):

    def __init__(self):
        self._dp_mgr = dptrp1manager.DPManager('digitalpaper.local')
        self._config = dptrp1manager.DPConfig(self._dp_mgr)
        self._downloader = dptrp1manager.Downloader(self._dp_mgr)
        self._uploader = dptrp1manager.Uploader(self._dp_mgr)
        self._synchronizer = dptrp1manager.Synchronizer(self._dp_mgr)
        # command line parser
        parser = argparse.ArgumentParser(
            description='Command line manager for the Sony DPT-RP1',
            usage='''dpmgr <command> [<args>]

The dpmgr commands are:
   upload      Upload files or directory contents to the digital paper device
   download    Download files or directory contents from the digital paper device
   sync        Synchronize files or directory contents with the digital paper device
   syncpairs   Synchronize pairs defined in the config file ~/.dpmgr/sync.conf
   config      Manage the configuration of the device
   status      Check the device status
''')
        parser.add_argument('command', help='Subcommand to run')
        # parse_args defaults to [1:] for args, but you need to
        # exclude the rest of the args too, or validation will fail
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.command):
            print('Unknown command')
            parser.print_help()
            exit(1)
        # use dispatch pattern to invoke method with same name
        getattr(self, args.command)()

    def upload(self):
        parser = argparse.ArgumentParser(
            description='Upload files (.pdf) or directory contents to the \
            digital paper device.\
            By default, skip files on conflict, i.e. when a file \
            is present locally and on the remote device.')
        parser.add_argument('local', help='Path to the local file or directory')
        parser.add_argument('remote', help='Path to the remote file or directory')
        parser.add_argument('-d', '--dir', action='store_true',
                help='Upload a whole directory.')
        parser.add_argument('-a', '--all', action='store_true',
                help='Upload all, that is, the whole subdirectory structure.')
        parser.add_argument('-r', '--remote', action='store_true',
                help='Prefer the remote file in case of a conflict.')
        parser.add_argument('-l', '--local', action='store_true',
                help='Prefer the local file in case of a conflict.')
        parser.add_argument('-n', '--newer', action='store_true',
                help='Prefer the newer file in case of a conflict.')
        args = parser.parse_args(sys.argv[2:])
        print('Running command "dpmgr upload" with arguments {}'.format(args))

    def download(self):
        parser = argparse.ArgumentParser(
            description='Download files or directory contents from the \
            digital paper device.\
            By default, skip files on conflict, i.e. when a file \
            is present locally and on the remote device.')
        parser.add_argument('remote', help='Path to the remote file or directory')
        parser.add_argument('local', help='Path to the local file or directory')
        parser.add_argument('-d', '--dir', action='store_true',
                help='Download a whole directory.')
        parser.add_argument('-a', '--all', action='store_true',
                help='Download all, that is, the whole subdirectory structure.')
        parser.add_argument('-r', '--remote', action='store_true',
                help='Prefer the remote file in case of a conflict.')
        parser.add_argument('-l', '--local', action='store_true',
                help='Prefer the local file in case of a conflict.')
        parser.add_argument('-n', '--newer', action='store_true',
                help='Prefer the newer file in case of a conflict.')
        args = parser.parse_args(sys.argv[2:])
        print('Running command "dpmgr download" with arguments {}'.format(args))

    def sync(self):
        parser = argparse.ArgumentParser(
            description='Synchronize directory contents between the \
            digital paper device and a local directory.\
            By default, skip files on conflict, i.e. when a file \
            is present locally and on the remote device.')
        parser.add_argument('local', help='Path to the local directory')
        parser.add_argument('remote', help='Path to the remote directory')
        parser.add_argument('-r', '--remote', action='store_true',
                help='Prefer the remote file in case of a conflict.')
        parser.add_argument('-l', '--local', action='store_true',
                help='Prefer the local file in case of a conflict.')
        parser.add_argument('-n', '--newer', action='store_true',
                help='Prefer the newer file in case of a conflict.')
        args = parser.parse_args(sys.argv[2:])
        print('Running command "dpmgr sync" with arguments {}'.format(args))

    def syncpairs(self):
        parser = argparse.ArgumentParser(
            description='Synchronize pairs defined in the config \
            file ~/.dpmgr/sync.conf.')
        print('Running command "dpmgr syncpairs"')

    def config(self):
        parser = argparse.ArgumentParser(
            description='Manage the configuration of the device')
        # TODO

    def status(self):
        parser = argparse.ArgumentParser(
            description='Check the device status')
        # TODO


if __name__ == '__main__':
    DPTRP1()
