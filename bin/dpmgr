#!/usr/bin/env python
# coding=utf-8

# dptrp1manager, high level tools to interact with the Sony DPT-RP1
# Copyright Â© 2018 Christian Gross

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


import argparse
import sys
import os

import dptrp1manager

class DPTRP1(object):

    def __init__(self):
        self._dp_mgr = dptrp1manager.DPManager()
        self._config = dptrp1manager.DPConfig(self._dp_mgr)
        self._downloader = dptrp1manager.Downloader(self._dp_mgr)
        self._uploader = dptrp1manager.Uploader(self._dp_mgr)
        self._synchronizer = dptrp1manager.Synchronizer(self._dp_mgr)
        # command line parser
        parser = argparse.ArgumentParser(
            description='Command line manager for the Sony DPT-RP1',
            usage='''dpmgr <command> [<args>]

The dpmgr commands are:
   upload      Upload files or directory contents to the digital paper device
   download    Download files or directory contents from the digital paper device
   tree        List documents and directories on the digital paper device in a tree
   delete      Delete documents and directories on the digital paper device
   mkdir       Create a new directory on the digital paper device
   sync        Synchronize files or directory contents with the digital paper device
   syncpairs   Synchronize pairs defined in the config file ~/.dpmgr/sync.conf
   status      Check the device status
   config      Manage the configuration of the device
   add-wifi    Add a wifi network
   delete-wifi Delete a wifi network
   scan-wifi   Scan for the available wifi networks

Configuration files, id and key files are stored in ~/.dpmgr.
''')
        parser.add_argument('command', help='Subcommand to run')
        # parse_args defaults to [1:] for args, but you need to
        # exclude the rest of the args too, or validation will fail
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.command):
            print('Unknown command')
            parser.print_help()
            exit(1)
        # use dispatch pattern to invoke method with same name
        method = getattr(self, args.command.replace('-', '_'))
        method()

    def upload(self):
        parser = argparse.ArgumentParser(
            description='Upload files (.pdf) or directory contents to the \
            digital paper device.\
            By default, skip files on conflict, i.e. when a file \
            is present locally and on the remote device.')
        parser.add_argument('local', help='Path to the local file or directory')
        parser.add_argument('remote', help='Path to the remote file or directory')
        group1 = parser.add_mutually_exclusive_group()
        group1.add_argument('-d', '--dir', action='store_true',
                help='Upload a whole directory.')
        group1.add_argument('-a', '--all', action='store_true',
                help='Upload all, that is, the whole subdirectory structure.')
        group2 = parser.add_mutually_exclusive_group()
        group2.add_argument('-r', '--remote_wins', action='store_true',
                help='Prefer the remote file in case of a conflict.')
        group2.add_argument('-l', '--local_wins', action='store_true',
                help='Prefer the local file in case of a conflict.')
        group2.add_argument('-n', '--newer', action='store_true',
                help='Prefer the newer file in case of a conflict.')
        # decide what to do
        args = parser.parse_args(sys.argv[2:])
        policy = 'skip'
        if args.remote_wins:
            policy = 'remote_wins'
        elif args.local_wins:
            policy = 'local_wins'
        elif args.newer:
            policy = 'newer'
        if args.all:
            self._uploader.upload_recursively(args.local, args.remote, policy)
        elif args.dir:
            self._uploader.upload_folder_contents(args.local, args.remote, policy)
        else:
            self._uploader.upload_file(args.local, args.remote, policy)

    def download(self):
        parser = argparse.ArgumentParser(
            description='Download files or directory contents from the \
            digital paper device.\
            By default, skip files on conflict, i.e. when a file \
            is present locally and on the remote device.')
        parser.add_argument('remote', help='Path to the remote file or directory')
        parser.add_argument('local', help='Path to the local file or directory')
        group1 = parser.add_mutually_exclusive_group()
        group1.add_argument('-d', '--dir', action='store_true',
                help='Download a whole directory.')
        group1.add_argument('-a', '--all', action='store_true',
                help='Download all, that is, the whole subdirectory structure.')
        group2 = parser.add_mutually_exclusive_group()
        group2.add_argument('-r', '--remote_wins', action='store_true',
                help='Prefer the remote file in case of a conflict.')
        group2.add_argument('-l', '--local_wins', action='store_true',
                help='Prefer the local file in case of a conflict.')
        group2.add_argument('-n', '--newer', action='store_true',
                help='Prefer the newer file in case of a conflict.')
        # decide what to do
        args = parser.parse_args(sys.argv[2:])
        policy = 'skip'
        if args.remote_wins:
            policy = 'remote_wins'
        elif args.local_wins:
            policy = 'local_wins'
        elif args.newer:
            policy = 'newer'
        if args.all:
            self._downloader.download_recursively(args.remote, args.local, policy)
        elif args.dir:
            self._downloader.download_folder_contents(args.remote, args.local, policy)
        else:
            self._downloader.download_file(args.remote, args.local, policy)

    def tree(self):
        parser = argparse.ArgumentParser(
            description='List documents and directories on the digital paper device \
                    in a tree structure.')
        parser.add_argument('remote_path', help='Path to the root remote directory.')
        parser.add_argument('-a', '--all', action='store_true',
                help='List all, that is, include also files.')
        args = parser.parse_args(sys.argv[2:])
        if args.all:
            self._dp_mgr.print_folder_contents(args.remote_path)
        else:
            self._dp_mgr.print_dir_tree(args.remote_path)

    def delete(self):
        parser = argparse.ArgumentParser(
            description='Delete documents and directories on the digital paper device')
        parser.add_argument('remote_path', help='Path to the root remote file or directory.')
        group1 = parser.add_mutually_exclusive_group()
        group1.add_argument('-a', '--all', action='store_true',
                help='Remove all files in the directory, but do not recurse into subdirectories.')
        group1.add_argument('-r', '--recursive', action='store_true',
                help='Remove all files and subdirectories in the directory.')
        # decide what to do
        args = parser.parse_args(sys.argv[2:])
        if args.all:
            self._dp_mgr.rm_allfiles_recursively(args.remote_path)
        elif args.dir:
            self._dp_mgr.rm_allfiles(args.remote_path)
        else:
            self._dp_mgr.rm(args.remote_path)

    def mkdir(self):
        parser = argparse.ArgumentParser(
            description='Create a new directory on the digital paper device')
        parser.add_argument('remote_path', help='Path of the new remote directory.')
        args = parser.parse_args(sys.argv[2:])
        self._dp_mgr.mkdir(args.remote_path)

    def sync(self):
        parser = argparse.ArgumentParser(
            description='Synchronize directory contents between the \
            digital paper device and a local directory.\
            By default, skip files on conflict, i.e. when a file \
            is present locally and on the remote device.')
        parser.add_argument('local', help='Path to the local directory')
        parser.add_argument('remote', help='Path to the remote directory')
        group2 = parser.add_mutually_exclusive_group()
        group2.add_argument('-r', '--remote_wins', action='store_true',
                help='Prefer the remote file in case of a conflict.')
        group2.add_argument('-l', '--local_wins', action='store_true',
                help='Prefer the local file in case of a conflict.')
        group2.add_argument('-n', '--newer', action='store_true',
                help='Prefer the newer file in case of a conflict.')
        # decide what to do
        args = parser.parse_args(sys.argv[2:])
        policy = 'skip'
        if args.remote_wins:
            policy = 'remote_wins'
        elif args.local_wins:
            policy = 'local_wins'
        elif args.newer:
            policy = 'newer'
        self._synchronizer.sync_folder(args.local, args.remote, policy)

    def syncpairs(self):
        parser = argparse.ArgumentParser(
            description='Synchronize pairs defined in the config \
            file ~/.dpmgr/sync.conf.')
        self._synchronizer.sync_pairs()

    def config(self):
        parser = argparse.ArgumentParser(
            description='Manage the configuration of the device. \
                    Invoke without arguments to get a list of all \
                    parameters with their current value.')
        parser.add_argument('-s', '--set', metavar='par=val',
                help='Set a config parameter using the syntax parameter=value.')
        parser.add_argument('-g', '--get', metavar='par',
                help='Get the value of a configuration parameter.')
        args = parser.parse_args(sys.argv[2:])
        print('Running command "dpmgr config" with arguments {}'.format(args))
        # TODO

    def add_wifi(self):
        parser = argparse.ArgumentParser(
            description='Add a wifi network.')
        parser.add_argument('ssid', help='SSID (name) of the wifi network.')
        parser.add_argument('-s', '--secured', action='store_true',
                help='Indicate that the wifi is secured by a password.')
        parser.add_argument('-p', '--password',
                help='The password.')
        parser.add_argument('--static', action='store_true',
                help='Configure a static address.')
        parser.add_argument('--ip-address',
                help='The static ip address.')
        parser.add_argument('--gateway',
                help='The gateway for a static configuration.')
        parser.add_argument('--network-mask',
                help='The network mask for a static configuration.')
        parser.add_argument('--dns1',
                help='The address of the first dns server for a static configuration.')
        parser.add_argument('--dns2',
                help='The address of the second dns server for a static configuration.')
        parser.add_argument('--proxy', action='store_true',
                help='Behind a proxy')
        args = parser.parse_args(sys.argv[2:])
        print('Running command "dpmgr add_wifi" with arguments {}'.format(args))
        # TODO

    def delete_wifi(self):
        parser = argparse.ArgumentParser(
            description='Delete a wifi network.')
        parser.add_argument('ssid', help='SSID (name) of the wifi network.')
        parser.add_argument('secured', help='Indicate if the network is a secure one.')
        args = parser.parse_args(sys.argv[2:])
        print('Running command "dpmgr delete_wifi" with arguments {}'.format(args))
        # TODO

    def scan_wifi(self):
        parser = argparse.ArgumentParser(
            description='Scan the available wifi networks.')
        print('Running command "dpmgr scan_wifi"')
        # TODO

    def status(self):
        parser = argparse.ArgumentParser(
            description='Get the device status. \
                    Invoke without arguments to get a summary of \
                    the status with all known parameters.')
        parser.add_argument('-g', '--get', metavar='par',
                help='Get the value of a specific status parameter.')
        args = parser.parse_args(sys.argv[2:])
        print('Running command "dpmgr status" with arguments {}'.format(args))
        # TODO


if __name__ == '__main__':
    DPTRP1()
